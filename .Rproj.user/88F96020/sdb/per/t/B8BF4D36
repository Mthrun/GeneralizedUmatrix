{
    "collab_server" : "",
    "contents" : "GeneralizedUmatrix=function(Data,ProjectedPoints,PlotIt=TRUE,Cls=NULL,Toroid=TRUE,Tiled=FALSE,ComputeInR=FALSE){\n#V=GeneralizedUmatrix(ProjectedPoints,Data)\n#V=GeneralizedUmatrix(ProjectedPoints,Data,TRUE,Cls,TRUE)\n# Generalisierte U-Matrix fuer Projektionsverfahren\n# Erklaerung der Funktion in\n#D:\\Subversion\\lehre\\Vorlesungen\\KnowledgeDiscovery\\01Text\\04ProjektionenUndVisualisierung\\81DatenbionischeProjektionen\\05Schwaerme\\DataBionicSwarm.pptx\n#Folie 45-51\n# INPUT\n# Data[1:n,1:d]                          array of data: n cases in rows, d variables in columns\n# ProjectedPoints[1:n,OutputDimension]   n by OutputDimension matrix containing coordinates of the Projection: A matrix of the fitted configuration.\n                                         # see Projections/R/..\n# OPTIONAL\n# PlotIt                                 bool, defaut=FALSE, if =TRUE: U-Marix of every current Position of Databots will be shown\n# toroid\n## ComputeInR                                  =T: Rcode, =F Cpp Code\n\n# Output\n# Umatrix[Lines,Columns                     umatrix (see ReadUMX() dbt.DataIO)\n# EsomNeurons[Lines,Columns,weights]       3-dimensional numeric array (wide format), not wts (long format)\n# Bmu[1:n,OutputDimension]                 GridConverted Projected Points information converted by convertProjectionProjectedPoints() to predefined Grid by Lines and Columns\n# gplotres                                Ausgabe von ggplot\n# unbesetztePositionen                    Umatrix[unbesetztePositionen] =NA\n# author: MT 06/2015\n#1.Editor; MT 12/2015\ntoroid=Toroid\n# ErrorHandling\nif(any(is.nan(Data))) stop('Data contains NaNs')\nif(!is.matrix(ProjectedPoints)) stop('ProjectedPoints has to be a matrix')\nif(!is.matrix(Data)){\n  stop('Data has to be a matrix')\n}\nn=nrow(ProjectedPoints)\nc=ncol(ProjectedPoints)\nif(c>3 |c<2)\n  stop(paste0('Wrong number of Columns of ProjectedPoints: ',c))\nif(c==3){\n  ProjectedPoints=ProjectedPoints[,2:3]\n}\n#end  ErrorHandling\n\n\n##########################################################################\n# calcUmatrixHLP function\n##########################################################################\ncalcUmatrixHLP <- function(EsomNeurons,Toroid=T){\n  # Umatrix=calcUmatrixHLP(wts)\n  # Calculate the Umatrix for given EsomNeurons projection\n  # INPUT\n  # EsomNeurons[Lines,Columns,weights]\t\tneuronen aus EsomNeurons\n  # OPTIONAL\n  # Toroid\t\t\t\tplanar=F\n  # OUTPUT\n  # Umatrix[Lines,Columns]\n  #############################################\n  ## Nachbarn()\n  nachbarn <- function(k, EsomNeurons, Toroid=FALSE){\n    # INPUT\n    # k Gitterpunkt\n    # EsomNeurons[Lines,Columns,weights]\n    # Toroid\n    # OUTPUT\n    # nb\n    M <- dim(EsomNeurons)[1]\n    N <- dim(EsomNeurons)[2]\n    if(Toroid){ \n      pos1 = c(k[1]-1,k[1]-1,k[1]-1,k[1],k[1],k[1]+1,k[1]+1,k[1]+1) %% M\n      pos1[which(pos1==0)] = M\n      pos2 = c(k[2]-1,k[2],k[2]+1,k[2]-1,k[2]+1,k[2]-1,k[2],k[2]+1) %% N\n      pos2[which(pos2==0)] = N\n      nb = cbind(pos1,pos2)\n    }else{# planar\n      if(k[1] == 1){\n        if (k[2] == 1){\n          nb = rbind(c(1,2), c(2,2), c(2,1))\n        }else{ \n          if (k[2] == N){\n            nb = rbind(c(1,(N-1)), c(2,(N-1)), c(2,N))\n          }else{ \n            nb = rbind(c(1,(k[2]-1)), c(1,(k[2]+1)), c(2,(k[2]-1)), c(2,k[2]), c(2,(k[2]+1)))\n          }\n        }\n      }#end fall 1 fuer planar\n      if(k[1] == M){\n        if(k[2] == 1){\n          nb = rbind(c((M-1),1), c((M-1),2), c(M,2))\n        }else{\n          if(k[2] == N){\n            nb = rbind(c((M-1),(N-1)), c((M-1),N), c(M,(N-1)))\n          }else{\n            nb = rbind(c((M-1),(k[2]-1)), c((M-1),k[2]), c((M-1),(k[2]+1)), c(M,(k[2]-1)), c(M,(k[2]+1)))\n          }\n        }\n      }#end fall 2 fuer planar\n      if(k[1] != 1 && k[1] != M){\n        if(k[2] == 1){\n          nb = rbind(c((k[1]-1),1), c((k[1]-1),2), c(k[1],2),c((k[1]+1),1), c((k[1]+1),2))\n        }else{ \n          if(k[2] == N){\n            nb = rbind(c((k[1]-1),(N-1)), c((k[1]-1),N), c(k[1],(N-1)), c((k[1]+1),(N-1)), c((k[1]+1),N))\n          }else{\n            nb = rbind(c((k[1]-1),(k[2]-1)), c((k[1]-1),k[2]), c((k[1]-1),(k[2]+1)), c(k[1],(k[2]-1)),c(k[1],(k[2]+1)), c((k[1]+1),(k[2]-1)), c((k[1]+1),k[2]), c((k[1]+1),(k[2]+1)))\n          }\n        }\n      }#end fall 3 fuer planar\n    }# end if Toroid\n    return(nb)\n  }\n  ############################################\n  k = dim(EsomNeurons)[1]\n  m = dim(EsomNeurons)[2]\n  Umatrix = matrix(0,k,m)\n  d=dim(EsomNeurons)[3]\n  if(is.null(d)){#wts als liste\n    stop('EsomNeurons wts has to be an array[1:Lines,1:Columns,1:Weights], use ListAsEsomNeurons')\n  }\n  for(i in 1:k){\n    for(j in 1:m){\n      nbs=nachbarn(c(i,j),EsomNeurons,Toroid)\n      wij=EsomNeurons[i,j,]\n      n.nbs=dim(nbs)[1]\n      for(l in 1:n.nbs){\n        nij=EsomNeurons[nbs[l,1],nbs[l,2],]\n        Umatrix[i,j]=Umatrix[i,j]+sqrt(sum((wij-nij)^2))\n      }\t\n      Umatrix[i,j]=Umatrix[i,j]/n.nbs\n    }\n  }\n  return(Umatrix)\n}\n##############End calcUmatrixHLP()\n##########################################################################\n# gridNeighbourhoodPattern function\n##########################################################################\n\ngridNeighbourhoodPattern <- function(Radius){\n  # gridNeighbourhoodPattern(Radius)\n  # returns index for neighbours relative to (0,0) and their distances\n  #\n  # INPUT\n  # Radius\t\t      Radius in which neighbours should be searched\n  # \n  # OUTPUT\n  # Neighbourhood(1:m,1:3)      positions of all weights in the Neighbourhood of c(0,0) together with their distance\n  # author: Florian Lerch\n  # gridNeighbourhoodPattern(3)\n  \n  # the pattern is starting from point 0,0\n  #author: FL\n  startPoint = c(0,0) \n  \n  # get all neighbours\n  Neighbourhood <- c()\n  \n  # make sure that Radius is an integer\n  Radius <- floor(Radius)\n  \n  # calculate only a quarter of the sphere and get the rest through symmetry\n  for (y in (startPoint[1] - Radius):(startPoint[1])){\n    for (x in (startPoint[2] - Radius):(startPoint[2])){\n      if ((y - startPoint[1])^2 + (x - startPoint[2])^2 <= Radius^2) {\n        ySym <- startPoint[1] - (y - startPoint[1])\n        xSym <- startPoint[2] - (x - startPoint[2])\n        \n        # add the new found neighbours and the points symmetric to them into the Neighbourhood\n        nn1 <- c(y, x, sqrt(y^2+x^2))\n        nn2 <- c(y, xSym, sqrt(y^2+xSym^2))\n        nn3 <- c(ySym , x, sqrt(ySym^2+x^2))\n        nn4 <- c(ySym, xSym, sqrt(ySym^2+xSym^2))\n        \n        newNeighbours <-  matrix(c(nn1, nn2, nn3, nn4),ncol=3,byrow=TRUE)\n        Neighbourhood <- rbind(Neighbourhood,newNeighbours)\n      }\n    }\n  }\n  \n  # remove duplicated entries\n  Neighbourhood <- unique(Neighbourhood)\n  \n  # sort by distance, this makes it easier to remove the farther neighbour on a Toroid\n  Neighbourhood <- Neighbourhood[order(Neighbourhood[,3]),] \n  \n  Neighbourhood\n}\n# end GridneighbourhoodThroughPattern function\n##########################################################################\n# neighbourhoodThroughPattern function\n##########################################################################\nneighbourhoodThroughPattern <- function(Index, Pattern, Columns, Lines, Toroid=TRUE, RadiusBiggerThanTorus=TRUE){\n  # neighbourhoodThroughPattern(Index, Pattern, Columns, Lines, Toroid)\n  # gets a Pattern for neighbourhood and returns all indices within that pattern starting from\n  # Index\n  #\n  # INPUT\n  # Index\t\t\tposition of a weightvector for which the neighbours should be returned. Index in form (lines,columns)\n  # Pattern\t\t\tThe neighbourhoodpattern. (see gridNeighbourhoodPattern)\n  # Columns\t\t\tWidth of the grid\n  # Lines\t\t\tHeight of the grid\n  # OPTIONAL\n  # Toroid\t\t\tIs the Pattern build on a Toroid?\n  # RadiusBiggerThanTorus\t\tIf the currently used radius is bigger than min(Columns/2,Lines/2)\n  #\t\t\t\t        there needs to be an expensive check for neighbours on two\n  #\t\t\t\t        sides over the Toroid\n  # OUTPUT\n  # Neighbourhood(1:m,1:2)       indices of all weights in the Neighbourhood of Index together with their distance\n  # author: Florian Lerch\n  # neighbourhoodThroughPattern(c(3,5), Pattern, 80, 50)\n  \n  # move points according to difference\n  Neighbourhood <- addRowWiseC(Pattern,c(Index,0))\n  \n  if(Toroid==FALSE){ # just keep points within the borders \n    Neighbourhood <- subset(Neighbourhood, Neighbourhood[,1] >= 1 & Neighbourhood[,2] >= 1 & \n                              Neighbourhood[,1] <= Lines & Neighbourhood[,2] <= Columns)\n    rows = Neighbourhood[,1]\n    cols = Neighbourhood[,2]\n  }\n  else if(Toroid==TRUE){ \n    # use modulo operator to get all entries into the borders\n    rows = (Neighbourhood[,1]) %% Lines \n    cols = (Neighbourhood[,2]) %% Columns \n    \n    rows[(rows == 0)] = Lines\n    cols[(cols == 0)] = Columns\n  }\n  \n  indices <- (rows-1)*Columns + cols\n  \n  Neighbourhood <- cbind(indices,Neighbourhood[,3])\n  \n  #RadiusBiggerThanTorus = F\n  # on a Toroid its possible that a value exists two times in the Neighbourhood\n  if(RadiusBiggerThanTorus){\n    Neighbourhood = Neighbourhood[!duplicated(Neighbourhood[,1]),]\n  }\n  \n  Neighbourhood\n}\n##############End neighbourhoodThroughPattern()\n##########################################################################\n# Koordinatenbestimmung auf Gitter\n##########################################################################\nif(n>4096/8)\n  minNeurons=n*8\nelse\n  minNeurons=4096\ncoordsres=XYcoords2LinesColumns(X=ProjectedPoints[,1],Y=ProjectedPoints[,2],PlotIt=F,minNeurons = minNeurons)\n\nLines=coordsres$LC[1]\nColumns=coordsres$LC[2]\nBMUs=coordsres$GridConvertedPoints\nBMUs[,1]=Lines-BMUs[,1]+1\nd=ncol(Data) #NumberOfweights\nk=Lines+5\nm=Columns+5\n\n#Hier ist nur relevant, das der Radius mindestens so gross ist, das in innerhalb des Radius um ein BMU\n# noch jeweils ein anderer BMU liegt\n# ansonsten fuert ein hoeherer Anfangsradius nur zu einer laengeren Berechnungsdauer\nHeuristischerParameter=max(round(Columns/6,0),20)\n#print(HeuristischerParameter)\n#HeuristischerParameter=20\n##########################################################################\n# Bestimmung der Positionen, auf welchen sESOM keinen Einfluss haben kann\n##########################################################################\n#path=paste0(SubversionDirectory(),'PUB/dbt/Umatrix/src/')\n#requireRpackage(\"Rcpp\")\n#sourceCpp(paste0(path,\"addRowWiseC.cpp\"))\n\nRadius=HeuristischerParameter\npattern=gridNeighbourhoodPattern(Radius)\nbmPos=lapply(1:nrow(coordsres$GridConvertedPoints),FUN=function(i,coordsres,pattern,Radius){\n  index=coordsres$GridConvertedPoints[i,]\n  res=neighbourhoodThroughPattern(index,pattern,coordsres$LC[2],coordsres$LC[1],T)\n  t(sapply(res[,1],FUN=function(ind,Columns){\n    row = ((ind-1) %/% Columns) + 1\n    col = ((ind-1) %% Columns) + 1\n    c(row,col)\n  },coordsres$LC[2]))\n},coordsres,pattern,Radius)\n\nbesetztPos=do.call(rbind,bmPos)\n\nRadius2=max(coordsres$LC[1],coordsres$LC[2])\npattern2=gridNeighbourhoodPattern(Radius2)\nres2=neighbourhoodThroughPattern(c(1,1),pattern2,coordsres$LC[1],coordsres$LC[2],T)\nallePositionen=t(sapply(res2[,1],FUN=function(ind,Columns){\n  row = ((ind-1) %/% Columns) + 1\n  col = ((ind-1) %% Columns) + 1\n  c(row,col)\n},coordsres$LC[2]))\n\nunbesetztePositionen=setdiffMatrix(allePositionen,besetztPos)$CurtedMatrix\n\n##########################################################################\n# Begin. simplified ESOM Algorithmus for given BestMatching units\n##########################################################################\n\nrnd=runif(n=d*k*m, min =min(Data), max = max(Data)) #besser als min(data) bis max(data)\nwts<- array(rnd,c(k,m,d)) #[Lines,Columns,weights]\n# BestMatches werden festgehalten\nfor(i in c(1:nrow(BMUs))){\n  wts[BMUs[i,1],BMUs[i,2],] = Data[i,]\n\n}\n#Jeder Radius sollte min. 1 Eppoche durchlaufen werden, mehr als eine Eppoche fuehrte nicht zu mehr Emergenz\n# s. auch Experimente mit iUmatrix(), wo eine Umatrix als Video pro Eppoche bei diverser Parameterwahl gezeichnet wird\nepochs=HeuristischerParameter\nAnfangsRadius=HeuristischerParameter\nvec=pmax(seq(from=AnfangsRadius-1,by=-1,length.out = HeuristischerParameter),1)\nfor (i in vec){\n  CurrentRadius =  i#max(AnfangsRadius-i,1) #Endradius=1\n  #Algorithmus\n  wts=sESOM4BMUs(BMUs,Data, wts, toroid, CurrentRadius,ComputeInR=ComputeInR)\n  print(paste0('Operator: getUmatrix4BMUs() at ',round(1-(i/HeuristischerParameter),2)*100,'%'))\n} # end 1:epochs\n##########################################################################\n# End, simplified ESOM Algorithmus for given BestMatching units\n##########################################################################\n  print(paste0('Operator: calcUmatrix() generates U-Matrix now...'))\n\n  Umap=calcUmatrixHLP(wts,Toroid=toroid)\n\n  #Umap[unbesetztePositionen]=NA\n  gplotres=NULL\nif(PlotIt){\nplotTopographicMap(Umap,BMUs,Cls,Tiled =Tiled,BmSize =1) #Sondern Gebirge=Unbekannte Orte der U-Matrix\n}\n\nreturn(list(Umatrix=Umap,EsomNeurons=wts,Bestmatches=BMUs,Lines=Lines,Columns=Columns,\n            unbesetztePositionen=unbesetztePositionen,\n       sESOMparamaters=list(Eppochs=HeuristischerParameter,Rmax=HeuristischerParameter,Rmin=1,CoolingStrategie='Linear, Lernratate ist const =1',Toroid=toroid),\n       gplotres=gplotres))\n\n\n}\n",
    "created" : 1489409684504.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "374871115",
    "id" : "B8BF4D36",
    "lastKnownWriteTime" : 1489410421,
    "last_content_update" : 1489410421650,
    "path" : "D:/Subversion/PUB/CRANupload/GeneralizedUmatrix/R/GeneralizedUmatrix.R",
    "project_path" : "R/GeneralizedUmatrix.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}